---
slug: should-i-usestate-or-usereducer
date: 2020-03-02
title: 'Should I useState or useReducer?'
author: 'Kent C. Dodds'
description:
  Two built-in React hooks that handle state, which one should you use?
categories: ['react']
keywords: ['react', 'javascript', 'hooks']
banner: './banner.png'
bannerCredit:
  Photo by [Kyle Glenn](https://unsplash.com/photos/IFLgWYlT2fI) on
  [Unsplash](https://unsplash.com/search/photos/uncertain)
---

Whenever there are two things to do the same thing, people inevitably ask: "When
do I use one over the other?" There are two possible reasons for having multiple
ways of doing the same thing:

1. One is the "old way" and the other is the "new (and improved) way". Typically
   the old way is kept around for backward compatibility reasons and the new way
   is the path forward for new code. For example: class components (old way) vs
   function components (new way).
2. They come with different trade-offs that should be considered and therefore
   should be applied in situations that suit them better (sometimes meaning
   you'll use more than one in a given application). For example:
   [`useEffect` vs `useLayoutEffect`](/blog/useeffect-vs-uselayouteffect) or
   [Static vs Unit vs Integration vs E2E tests](/blog/unit-vs-integration-vs-e2e-tests)
   or
   ["Control Props" vs "State Reducers"](/blog/control-props-vs-state-reducers)

`useState` and `useReducer` fall into the second category here. So let's talk
about the trade-offs

(and no, it's not a
[trick question](https://twitter.com/ryanflorence/status/1234534306707456000)
ðŸ˜‚).

## Examples

I think the best way to discuss these trade-offs is through the lens of
examples. We'll look at two examples. One which suits `useState` better, and one
which suits `useReducer` better. This won't be enough to cover all of the
trade-offs, but hopefully can be a good starting point for us.

### Custom `useGeoLocation` hook

#### `useState` implementation

```javascript
function useGeoPosition() {
  const [position, setPosition] = useState(null)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!navigator.geolocation) {
      setError(new Error('Geolocation is not supported'))
      return
    }
    const geoWatch = navigator.geolocation.watchPosition(
      (position) =>
        setPosition(position,
      error => setError(error),
    )
    return () => navigator.geolocation.clearWatch(geoWatch)
  }, [])

  return {position, error}
}
```

This is an example of situation that is not as well suited for `useState`. There
are actually some problems with this approach. Can you think of what those might
be? Let me show you how a developer might use this hook:

```jsx
function YourPosition() {
  const {position, error} = useGeoPosition()
  if (!position && !error) {
    return <div>Loading your position...</div>
  } else if (position) {
    return (
      <div>
        Lat: {position.coords.latitude}, Long: {position.coords.longitude}
      </div>
    )
  } else if (error) {
    return (
      <div>
        <div>Oh no, there was a problem getting your position:</div>
        <pre>{error.message}</pre>
      </div>
    )
  }
}
```

Can you identify the problem yet? No? Imagine what would happen if the user were
to hop into a car, started driving around, and the device failed with a
`GeolocationPositionError.POSITION_UNAVAILABLE` or
`GeolocationPositionError.TIMEOUT` or even if the user decided to disable the
geoposition permission for your app and you got a
`GeolocationPositionError.PERMISSION_DENIED`. What would happen then? With the
way the component above is written, we'd always show the last recorded position
and never show the user the error message!

If we swapped things around and only show the position if there's no error, then
we'd have the opposite problem: we'd only show an error, even if subsequent
requests for the position succeeded.

There are a few ways we could change this to avoid that problem:

1. Ensure users of the hook always show the position AND error if they're
   available.
2. Clear the `error` when getting the position is successful, and clear the
   `position` if there's an error.
3. Return an additional property indicating the current status of the
   geoposition information.

As a creator of something reusable, it's always easier to make it so people
_can't_ do the wrong thing even if they _want_ to or at least it's more natural
to do the right thing than the wrong thing (pit of success and all that). So
option #1 is out. For option #2, there may be some people who want to show the
most recent position even if there was an error, so that won't work. So let's go
with option #3:

```javascript
function useGeoPosition() {
  const [status, setStatus] = React.useState('idle')
  const [position, setPosition] = useState(null)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!navigator.geolocation) {
      setStatus('rejected')
      setError(new Error('Geolocation is not supported'))
      return
    }
    setStatus('pending')
    const geoWatch = navigator.geolocation.watchPosition(
      position => {
        setStatus('resolved')
        setPosition(position)
      },
      error => {
        setStatus('rejected')
        setError(error)
      },
    )
    return () => navigator.geolocation.clearWatch(geoWatch)
  }, [])

  return {status, position, error}
}
```

Awesome, now users can use the `status` to render instead:

```jsx
function YourPosition() {
  const {status, position, error} = useGeoPosition()
  if (status === 'idle' || status === 'pending') {
    return <div>Loading your position...</div>
  } else if (status === 'resolved') {
    return (
      <div>
        Lat: {position.coords.latitude}, Long: {position.coords.longitude}
      </div>
    )
  } else if (status === 'rejected') {
    return (
      <div>
        <div>Oh no, there was a problem getting your position:</div>
        <pre>{error.message}</pre>
      </div>
    )
  }
}
```

Now, we've solved the problem, and we did it with `useState`, so why do we need
`useReducer`? Well, let's checkout what this example would be like with
`useReducer` instead...

#### `useReducer` implementation

```javascript
function geoPositionReducer(state, action) {
  switch (action.type) {
    case 'error': {
      return {
        status: 'rejected',
        error: action.error,
        ...state,
      }
    }
    case 'success': {
      return {
        status: 'resolved',
        position: action.position,
        ...state,
      }
    }
    case 'started': {
      return {
        status: 'pending',
        ...state,
      }
    }
    default: {
      throw new Error(`Unhandled action type: ${action.type}`)
    }
  }
}

function useGeoPosition() {
  const [state, dispatch] = React.useReducer(geoPositionReducer, {
    status: 'idle',
    position: null,
    error: null,
  })

  useEffect(() => {
    if (!navigator.geolocation) {
      dispatch({
        type: 'error',
        error: new Error('Geolocation is not supported'),
      })
      return
    }
    dispatch({type: 'started'})
    const geoWatch = navigator.geolocation.watchPosition(
      position => dispatch({type: 'success', position}),
      error => dispatch({type: 'error', error}),
    )
    return () => navigator.geolocation.clearWatch(geoWatch)
  }, [])

  return {status, position, error}
}
```

## One situation when `useReducer` is basically always better

**If your one element of your state relies on the value of another element of
your state, then it's almost always best to use `useReducer`**

For example, imagine you have a tic-tac-toe game you're writing. You have one
element of state called `squares` which is just an array of all the squares and
their value:

```
[
  ' ', 'X', 'O',
  'X', 'O', 'X',
  ' ', ' ', 'X'
]
```

and another called `xIsNext` which maintains the who's turn it is. When a user
clicks on a square, how does your code know whether the `squares` array should
update to `X` or `O`? It determines this based on the `xIsNext` state. Because
of this, it's easier to use a reducer because the reducer function can accept
all of the current state and use that current state (which includes `xIsNext`)
to determine the new state.

The benefits here are _mostly_ just code aesthetic, but if you start adding
async behavior here, then the case for `useReducer` is even more strong. With
our tic-tac-toe game, you can reference the current value of `xIsNext` in the
closure, but if you are updating the `squares` state asynchronously, then you
could be working with stale values of state which may or may not be what you
want. Using a reducer completely removes this potential issue though, which is
why I say it's basically always better to use a reducer if your state elements
depend on one another when they're updated.

Here's an example of tic-tac-toe with `useReducer`:

https://codesandbox.io/s/r1m6pz58mq

## Other considerations

Using previous values of state. When the current value of state A determines the
next value of state B.

[I asked about when people use each](https://twitter.com/kentcdodds/status/1234532781402640384)
and got a lot of answers where people stated what they consider to be a general
rule of thumb, but I disagree.

TODO: write more stuff here...

## Conclusion

So what's the answer? Really, it depends. `useState` is literally built on top
of `useReducer`. I don't think there are any relevant performance concerns
between the two so it's mostly a cosmetic/preferential decision.

While I conceptually like what Matt is encouraging, I think I may have a longer
threshold before I'll reach for `useReducer` to replace my `useState`. I also
really appreciate Matt for including this:

> they both have benefits and fallbacks that depend entirely upon their use

I think the best thing you can do to develop an intuition for when to reach for
one or the other is to feel the pain. Use them both and see how happy/sad they
make your life.

Good luck!
